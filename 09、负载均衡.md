## 09、负载均衡

### 1、常见负载均衡的方式（概念普及）

【1】用户手动选择

例如我们玩游戏，服务器会显示当前服务器的状态是拥挤、繁忙、还是空闲，然后用户根据自己实际需要，选择自己想去的服务器。

如果服务器人太多（达到上限），则触发排队，比如猪场主推的一些游戏，在刚上线的时候通常都特别火，要排很久，还有戏称阴兵的存在。

这个适合用户和用户之间需要交互的情况（且跨服务器之间无法交互，或交互比较麻烦）。

【2】DNS解析控制

需要知道一个前提，你访问同一个域名，第一次可能是1xx.1xx.1xx.1，第二次可能是1xx.1xx.1xx.2（即不同的ip）。

但由于这两个都是网站的服务器，所以不管访问哪个都一样。

在我们访问域名的时候，DNS解析服务器，会将你的域名转为IP，因此我们具体访问哪一个IP上的服务器，是根据DNS解析服务器来决定的。

以阿里云为例，我们可以配置云解析。

具体来说，我们可以设置 a.test.com 被解析为 1xx.1xx.1xx.1 和 1xx.1xx.1xx.2 ，甚至更多。

效果是当访问 a.test.com 时，用户可能跳转到 1xx.1xx.1xx.1 和 1xx.1xx.1xx.2 或者其他你设置的 ip 上。

<b>缺点：</b>

1. 假如 1xx.1xx.1xx.1 服务器挂了，所以被导向这个 IP 地址的流量，都不会得到相应;
2. 不是真负载均衡，特别在各个服务器高压力的情况下，部分服务器可能先达到 100% 负载，然后出现问题。

【3】涉及到网络七层协议的负载均衡

分为第四层（传输层）和第七层（网络层）两种。

第四层的负载均衡简单来说，当你访问到一个 IP 地址（外部）时，他会被映射到内部多个预先保存的 IP 地址（内部）中的一个。

第七层的负载均衡，是根据HTTP请求头的内容，来指向不同的服务器。

硬件实现，通常是通过交换机。软件实现，就各有所长了。

例如 Nginx 就是典型的通过软件的第七层来实现负载均衡。

【4】混合形式

比如：

* 根据访问者的地区，找不同地区的机房（例如来自长三角的流量找上海的机房）
* 根据访问者的网络，找不同运营商的机房（电信的找电信机房）
* 进了机房后，根据机子的负载不同，找负载低的服务器

### 2、Nginx反向代理的基本配置

配置很简单，核心属性是 ``proxy_pass``，可以直接指向域名

<b>解释：</b>

当访问 c.test.com 时，触发这里的反向代理配置（当然，需要先配置好host，让这个域名指向nginx服务器的IP），然后会重定向到 proxy_pass 配置的IP地址。

即：【访问nginx服务器】--反向代理-->【103.94.185.215:3000】

```
server {
    listen 80;
    # 监听的域名是 c.test.com，即用户访问 c.test.com 时，触发这个配置
    server_name c.test.com;

    location / {
        # 访问根域名，跳转到 http://103.94.185.215:3000/ 这个IP，这个IP是我自己的网站
        proxy_pass http://103.94.185.215:3000/;
    }
}
```


### 3、反向代理到多个服务器

以上只能反向代理到单个服务器，nginx也支持配置反向代理到多个服务器。

通过借用 upstream 属性，存储一个服务器列表，具体写法如下：

```
# 配置服务器列表
upstream my_server_list{
    server 185.186.147.210;
    server 103.94.185.215:3000;
}

# 配置 server
server {
    listen 80;
    # 监听的域名是 c.test.com，即用户访问 c.test.com 时，触发这个配置
    server_name c.test.com;

    location / {
        # 反向代理到 my_server_list 池中
        proxy_pass http://my_server_list;
    }
}
```

注意：

* upstream 和 server 的配置是同一级的；
* 每一个 server 一行，只写ip即使用默认端口80，也可以写上端口；
* 这里是最基本的配置，将在下面不断增加更复杂的内容；

### 4、属性详解

#### 4.1 proxy_set_header

位置：

```
http, server, location
```

格式：

```
proxy_set_header field value;

# 默认值
proxy_set_header Host $proxy_host;
proxy_set_header Connection close;
```

说明：

1. 这个属性用于配置nginx服务器传给后端服务器的请求的 request 的 header 属性；
2. 具体来说，使用反向代理时，流量的流向形式是：【客户端】->【nginx服务器】->【后端服务器】；
3. 以host属性为例，默认情况下：
	1. 当访问 c.test.com 时，【客户端】->【nginx服务器】这一步，request 的 header 为 c.test.com；
	2. 而【nginx服务器】->【后端服务器】这一步的header为 ``proxy_pass`` 属性中，``http://``属性后的字符串的值。例如 ``proxy_pass http://127.0.0.1:3000;`` ，则 host 的值为 ``127.0.0.1:3000``；
	3. 如果是 ``proxy_pass http://my_server_list;``，那么传给后端服务器的header里 host 字段值为 ``my_server_list``；
4. 如果想让 Host 值等于用户访问的域名，则需要这么设置 ``proxy_set_header Host $host;``
5. 也可以使用 ``$http_host`` 来替代 ``$host``，这个不同之处在于，当访问的不是 80/443 端口时，``$http_host`` 会带上端口值（示例：``c.test.com:81`` ）
	1. 几个属性值的区别，可以参考这个链接 <a href="http://schin.space/nginx/NGINX-%E5%85%B3%E4%BA%8Enginx%E4%B8%AD$host-$server_name-$http_host%E7%9A%84%E5%8C%BA%E5%88%AB/">关于nginx中host, server_name, http_host的区别</a>
6. 你也可以通过这个字段，来添加你想自定义的 header 属性对，或者覆写已有的字段值；
7. <b>注意：</b> field 里的大写字母，在后端拿到的header里，大写字母都已经被转为小写字母了。
8. 我们之前在【07、日志】里面，通过 ``http_x_forwarded_for`` 来拿取重定向之前，用户真实的 IP 地址，因此我们通常在做反向代理的时候，应该通过这个属性，将用户真实 IP 地址添加进去。写法如下：``proxy_set_header X-Forwarded-For $remote_addr;``

如果自定义header的话，示例配置如下：

```
server {
    listen 80;
    # 监听的域名是 c.test.com，即用户访问 c.test.com 时，触发这个配置
    server_name c.test.com;

    location / {
        # 反向代理到 my_server_list 池中
        proxy_pass http://my_server_list;
        # 在发送到后端服务器的 request 里的 header 里添加属性头 Abc ，值为 abcd
        proxy_set_header Abc abcd;
    }
}
```

后端服务器打个日志：

```
console.log('header-abc-', req.headers['abc']);
```

输出结果：

```
header-abc- abcd
```

### 4.2 